# 데이터 모델과 질의 언어
* 데이터 모델위에 계층을 둔 애플리케이션
  * 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨김 (추상화)
## 관계형 모델과 문서 모델
### SQL
* 관계형 모델
  * 관계(relation)
  * 각 관계는 순서 없는 tuple 모음
  * RDMBS
  * 관계형 데이터베이스의 근원
    * for 비즈니스 데이터 처리
      * 트랜잭션 처리
      * 일괄 처리
### NoSQL
  * 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 RDBMS보다 쉽게 할 수 있는 뛰어난 확장서의 필요
  * 상용 DB보다 open source sw에 대한 선호도 확산
  * 관계형 모델에서 지원하지 않는 특수 질의
  * 관계형 스키마의 제한에 대한 불만
    * 도적이고 표현력이 풍부한 데이터 모델에 대한 바람
### 객체 관계형 불일치
* 현재의 애플리케이션은 객체지향 프로그래밍 언어로 개발
  * SQL 데이터 모델과 패러다임이 다름 (impedance mismatch)
* ORM을 통해 SQL <> 객체지향 프로그래밍 간의 코드 양을 줄이지만 두 모델의 차이를 완벽히 숨기기는 어려움
### 다대일과 다대다 관계 
* 텍스트 직접 저장은 해당 정보를 사용하는 모든 레코드에서 정보를 중복 저장
* ID를 사용하는 경우 의미있는 정보는 한 곳에만 저장
  * 그것을 참조하는 모든 것은 ID를 사용해 참조 (DB 내에서)
  * ID 자체는 아무런 의미가 없으므로 식별 정보가 변경되어도 변경할 필요가 없음
* 중복된 데이터를 정규화하려면 **다대일**관계가 필요
  * RDBMS: Join (ID로 다른 테이블의 로우 참조)
  * Documents DB: Join-free
    * 데이터베이스에 대한 다중 질의를 만들어 APP에서 조인을 흉내내야..
      * Entity로서의 조직과 학교
### 어떤 데이터 모델이 코드를 더 간단하게 할까?
* 데이터가 문서와 비슷한 구조라면 Document model
  * 일대다 관계 트리로 보통 한 번에 전체 트리를 적재
  * 다대다 관계가 결코 필요하지 않은 경우
* 다대다 관계를 사용한다면 관계형 모델
  * 복잡도가 애플리케이션으로 이동
  * DB에서 특화된 join보다 더 느리다.
### 문서 모델에서의 스키마 유연성
* JSON은 문서의 데이터에 어떠한 스키마를 강요하지 않는다.
* RDBMS: schema-on-write 쓰기스키마
  * 명시적
  * 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장
  * 컴파일 타임 타입 확인과 유사
  * 데이터 타입 변경 시, 스키마 변경 및 데이터 마이그레이션 필요
    * mysql은 alter table시에 전체 테이블 복사 (중단 시간 발생)
```sql
ALTER TABLE users ADD COLUMN  first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1) -- postgresql
UPDATE users SET first_name = substring_index(name, ' ', 1) --mysql
```
  * Document DB: schema-on-read 읽기 스키마
    * 데이터 구조는 암묵적
    * 데이터를 읽을 때만 해석
    * 런타임 타임 타입 확인과 유사
    * 컬렉션 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리
```js
if (user && user.name && !user.first_name) {
  user.first_name = user.name.splt(" ")[0];
}
```
### 질의를 위한 데이터 지역성
* 애플리케이션이 자주 전체 문서에 접근해야할 때 저장소 지역성을 활용하면 성능 이점이 있음
* 테이블이 나눠져 있으면 다중 색인 검색이 필요하고, 더 많은 디스크 탐색을 필요로함